---
layout:     post
title:      AI Agent之完整的系统系架构
subtitle:   
date:       2026-02-19
author:     LuochuanAD
header-img: img/home_blog_background.jpg
catalog: true
tags: 
- AI Agent


---


## 完整的架构结构 Architecture
```
1. Intent Layer
2. Planning Layer
3. Execution Layer
4. Tool Layer
5. Memory Layer
6. Knowledge Layer
7. Policy & Guardrail Layer
8. Observability Layer
9. Persistence Layer
10. Governance Layer
```

## 1, 第一层:Intent Router

> Router 需要判断是否调用Tools

**Router Prompt:**

```
prompt = ‘

	You are a task classifier.
	User query: {query}
 
	Classify the user query into one of:
 
	1. simple_qa
	2. retrieval
	3. tool_call
	4. multi_step
 
	Return JSON:
	{
  		"type": "..."
	}
’
```
## 2, 第二层:ReAct Tool Core

```
1. simple_qa ==》LLM直接回答

2. retrieval ==》调用向量数据库直接检索/调用Browser检索

3. tool_call  ==》进入ReAct循环
4. multi_step ==》进入ReAct循环

```
### ReAct循环的架构:

```
LLM decides next action
↓
Call one tool
↓
Append tool result
↓
Repeat

```
**Sample Code:**

```
while True:
 
    response = llm(messages, tools=tool_schema)
 
    if response.tool_calls:
        result = execute_tool(...)
        messages.append(tool_result)
 
    else:
        break

```

## 3, 第三层:Structured Tool Layer

> 这里采用ChatGPT的Function Calling的思想,通过定义“**Tools Schema**”来连接LLM和Tools的调用.

企业级AIAgent:ReAct + Function calling:
[https://strictfrog.com/2026/02/17/%E4%BC%81%E4%B8%9A%E7%BA%A7AIAgent%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8Tools%E4%B9%8BReAct/](https://strictfrog.com/2026/02/17/%E4%BC%81%E4%B8%9A%E7%BA%A7AIAgent%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8Tools%E4%B9%8BReAct/)

## 4, 第四层:Guardrails & Policies

**最大步骤限制:**

```
max_steps = 15
```
**不允许发送敏感邮件:**
```
if tool = send_mail:
	require confirmation
```

## 5, 第五层:Memory Layer
```
统一 Memory 体系（长期 + 短期）

1️⃣ 短期记忆（Session Memory）
	•	当前任务的状态
	•	工具调用历史
	•	决策中间结果
2️⃣ 长期记忆（Persistent Memory）
	•	用户历史偏好
	•	历史任务记录
	•	决策结果存档
	•	邮件发送日志
否则系统无法：
	•	回溯
	•	分析
	•	审计
	•	学习优化
```

## 7, 第七层: Policy & Guardrail Layer
```
Policy & Safety Layer（安全控制）
现在可以自动发邮件。
危险问题：
	•	如果 prompt 注入？
	•	如果用户让它群发？
	•	如果泄露敏感信息？
	•	如果调用危险 API？
成熟系统必须有：
Guardrails
	•	工具调用白名单
	•	参数验证
	•	风险评分
	•	人工确认节点
	•	速率限制
```

## 8, 第八层:Observability Layer
```
Observability（可观测性）
必须能回答：
	•	哪个工具调用失败最多？
	•	平均任务执行多少步？
	•	LLM token 消耗多少？
	•	邮件成功率？
	•	哪个步骤最耗时？
这需要：
	•	结构化日志
	•	Step-level trace
	•	Metrics
	•	可视化 Dashboard
否则无法优化。
```

## 9, 第九层:Persistence Layer
```
任务持久化（Persistence）
必须支持：
	•	任务中断恢复
	•	异步执行
	•	多用户并发
	•	失败重试
	•	延迟执行
需要：
	•	Redis / DB 存储状态
	•	每个 Task 一个唯一 ID
	•	状态机持久化
否则不是系统，只是脚本。
```




## Tool Governance（工具治理）
```
当工具超过 10 个时，会出现：
	•	工具冲突
	•	参数混乱
	•	错误路由
	•	LLM 选择错误工具
成熟系统需要：
	•	工具注册中心
	•	Tool Capability 描述
	•	工具优先级
	•	工具调用日志
```

## Error Recovery Strategy
```
现在是：
 报错 → 程序崩溃

成熟系统必须有：
	•	自动重试
	•	备用模型
	•	回退策略
	•	LLM 自我修复提示
```

## 成本控制层

```
成熟系统必须监控：
	•	Token 使用量
	•	工具调用成本
	•	API 费用
	•	模型选择策略（小模型优先）
否则成本不可控。
```
## 人类干预节点（Human-in-the-loop）
```
当出现：
	•	高风险操作
	•	置信度低
	•	多候选模糊
必须：
 Agent → 请求人工确认

否则不能用于真实业务。
```
## 成熟的系统结构图

```
		┌──────────────────┐
                │   API Gateway    │
                └──────────────────┘
                          ↓
                ┌──────────────────┐
                │ Intent Router    │
                └──────────────────┘
                          ↓
                ┌──────────────────┐
                │ ReAct Engine     │
                └──────────────────┘
                          ↓
          ┌───────────────┼────────────────┐
          ↓               ↓                ↓
   Tool Layer       Knowledge Layer     Memory Layer
          ↓               ↓                ↓
                ┌──────────────────┐
                │ Policy Layer     │
                └──────────────────┘
                          ↓
                ┌──────────────────┐
                │ Persistence DB   │
                └──────────────────┘
                          ↓
                ┌──────────────────┐
                │ Observability    │
                └──────────────────┘

```
## 总结

```
成熟系统的标志
•	同时服务 100+ 用户
•	支持长链任务
•	中断恢复
•	失败自动修复
•	有完整审计日志
•	有成本统计
•	有安全策略
•	有人工审批节点

```

